---
title: "Restaurante and consumer data"
output: html_notebook
---

## ECDE - 2nd Semestre 2017/18

<b>Group 2:</b><br />
Alessandro Fragal√† N 84080<br />
Anderson Acosta N 81799<br />
Maria Sales N 83748<br />

## Business Undestanding

The selected dataset for this project is ["Restaurante and consumer data"](https://archive.ics.uci.edu/ml/datasets/Restaurant+%26+consumer+data#), which was extracted from the UCI Machine Learning Repository.
This dataset contains information about consumers, restaurants and ratings that consumers gave to restaurants, distributed among nine .csv files: five of them about restaurants, three have consumer information and the last one contains the ratings.
The main purpose for this project is to analyze the given data and predict the missing ratings.

## Data Understanding

#### Library installation
```{r}
install.packages("rminer")
library(rminer)
library(data.table)
```

#### Auxiliar functions
```{r}
# Calculate mode
calculateMode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Draw barplot
drawBarplot <- function(dataframe, type, title, xlab, ylab, feature) {
  count <- c()
  for(s in type) {
    value <- length(dataframe[which(dataframe[,feature] == s),feature])
    count <- c(count, value) # append to the end
  }
  # par(mar=c(10,10,1,1))
  bb <- barplot(count, main = title, xlab = xlab, ylab = ylab, names.arg = type, ylim = c(0, max(count) + max(count)*0.2)) # las = 2
  text(x = bb, y = count, labels = count, pos = 3)
}
```

First step to start analyzing the provided data is to read all the .csv files and store them in separate datasets.
```{r}

# Read datasets
# Restaurants
chefmozaccepts_df <- read.csv("chefmozaccepts.csv")
chefmozcuisine_df <- read.csv("chefmozcuisine.csv")
chefmozhours4_df <- read.csv("chefmozhours4.csv")
chefmozparking_df <- read.csv("chefmozparking.csv")
geoplaces2_df <- read.csv("geoplaces2.csv",encoding='latin-1')
# Consumers 
usercuisine_df <- read.csv("usercuisine.csv")
userpayment_df <- read.csv("userpayment.csv")
userprofile_df <- read.csv("userprofile.csv")
# User-Item-Rating
rating_final_df <- read.csv("rating_final.csv")
```

Then we want to analyze the imported data by visualizing important statistics about the datasets:

#### Dataset 1: chefmozaccepts

This dataset contains information about the payment methods that restaurants accept. It contains the following features:
- placeID: corresponds to the restaurant id;
- Rpayment: corresponds to the type of payment that the restaurant in the matching row accepts. This is a nominal feature with 12 levels.
From this analysis we conclude that this dataset has no missing values, but a treatment to Rpayment is necessary to reduce the number of levels of this feature.
```{r}
# Columns
names(chefmozaccepts_df)
# Number of attributes
ncol(chefmozaccepts_df)
# Number of instances
nrow(chefmozaccepts_df)
# Summary
summary(chefmozaccepts_df, maxsum = 1000)
# Head
head(chefmozaccepts_df)
# Number of nulls
sum(chefmozaccepts_df == "?")
# Number of nulls per column
colSums(chefmozaccepts_df == "?")
# Number of levels of Rpayment
sprintf("Rpayment has %d levels.", nlevels(chefmozaccepts_df$Rpayment))
```

#### Dataset 2: chefmozcuisine

This dataset contains information about the type of cuisine of the restaurants It contains the following features:
- placeID: corresponds to the restaurant id;
- Rcuisine: corresponds to the type of cuisine of the restaurant. This is a nominal feature with 59 levels.
From this analysis we conclude that this dataset has no missing values, but a treatment to Rcuisine is necessary to reduce the number of levels of this feature.
```{r}
# Columns
names(chefmozcuisine_df)
# Number of attributes
ncol(chefmozcuisine_df)
# Number of instances
nrow(chefmozcuisine_df)
# Summary
summary(chefmozcuisine_df, maxsum = 1000)
# Head
head(chefmozcuisine_df)
# Number of nulls
sum(chefmozcuisine_df == "?")
# Number of nulls per column
colSums(chefmozcuisine_df == "?")
# Number of levels of Rcuisine
sprintf("Rcuisine has %d levels.", nlevels(chefmozcuisine_df$Rcuisine))
```

#### Dataset 3: chefmozhours4

This dataset contains information about the hours and days that each restaurant is open/closed. It contains the following features:
- placeID: corresponds to the restaurant id;
- hours: corresponds to the hours that the restaurant is open/closed. This is a nominal feature with 273 levels;
- days: corresponds to the day of the week that the restaurant is open/closed. This is a nominal feature with 3 levels.
From this analysis we conclude that this dataset has no missing values, but a treatment to hours is necessary to reduce the number of levels of this feature.
```{r}
# Columns
names(chefmozhours4_df)
# Number of attributes
ncol(chefmozhours4_df)
# Number of instances
nrow(chefmozhours4_df)
# Summary
summary(chefmozhours4_df, maxsum = 1000)
# Head
head(chefmozhours4_df)
# Number of nulls
sum(chefmozhours4_df == "?")
# Number of nulls per column
colSums(chefmozhours4_df == "?")
# Number of levels of hours
sprintf("hours has %d levels.", nlevels(chefmozhours4_df$hours))
# Number of levels of days
sprintf("days has %d levels.", nlevels(chefmozhours4_df$days))
```

#### Dataset 4: chefmozparking

This dataset contains information about the parking that each restaurant offers. It contains the following features:
- placeID: corresponds to the restaurant id;
- parking_lot: corresponds to the type of parking. This is a nominal feature with 7 levels.
From this analysis we conclude that this dataset has no missing values, and no treatment is necessary.
```{r}
# Columns
names(chefmozparking_df)
# Number of attributes
ncol(chefmozparking_df)
# Number of instances
nrow(chefmozparking_df)
# Summary
summary(chefmozparking_df, maxsum = 1000)
# Head
head(chefmozparking_df)
# Number of nulls
sum(chefmozparking_df == "?")
# Number of nulls per column
colSums(chefmozparking_df == "?")
# Number of levels of parking_lot
sprintf("parking_lot has %d levels.", nlevels(chefmozparking_df$parking_lot))
```

##### Feature 4.1: parking_lot

A graphical visualization with a barplot shows the distribution of this feature.
```{r}
parking_lot <- unique(chefmozparking_df$parking_lot)
title <- "Total restaurants per parking lot type"
xlab <- "Parking Lot"
ylab <- "Restaurant count"
feature <- "parking_lot"
drawBarplot(chefmozparking_df, parking_lot, title, xlab, ylab, feature)
```

#### Dataset 5: geoplaces2

This dataset contains generic information about each restaurant. It contains the following features:
- placeID: corresponds to the restaurant id;
- latitude and longitude: correspond to the geospatial coordinates of the restaurant. These are both numeric features;
- the_geom_meter: geospatial variable. This is a nominal feature with 130 levels;
- name: name of the restaurant;
- address: address of the restaurant. This is a nominal feature with 100 levels and 27 missing values;
- city: city of the restaurant. This is a nominal feature with 17 levels and 18 missing values;
- state: state of the restaurant. This is a nominal feature with 13 levels and 18 missing values;
- country: country of the restaurant. This is a nominal feature with 3 levels and 28 missing values;
- fax: fax of the restaurant. This is a numeric feature with 130 missing values;
- zip: zip code of the restaurant. This is a numeric feature with 35 levels and 74 missing values;
- alcohol: indicates the type of bar service that the restaurant provides. This is a nominal feature with 3 levels;
- smoking_area: indicates the type of smoking area that the restaurant provides. This is a nominal feature with 5 levels;
- dress_code: dress code allowed in the restaurant. This is a nominal feature with 3 levels;
- accessibility: indicates the accessibility that the restaurant  provides for disabled people. This is a nominal feature with 3 levels;
- price: budget range of the restaurant. This is a nominal feature with 3 levels;
- url: url of the restaurant. Contains 116 missing values;
- Rambience: type of ambience of the restaurant. This is a nominal feature with 2 levels;
- franchise: indicates if the restaurant is a franchise or not. This is a nominal feature with 2 levels;
- area: indicates the type of the area of the restaurant. This is a nominal feature with 2 levels;
- other_services: indicates if the restaurant offers any additional service or not. This is a nominal feature with 3 levels.

From this analysis we conclude that this dataset needs the following treatments:
- drop the_geom_meter. The location of the restaurant will be given by the city
- discover the missing cities with the given latitute and longitude, and then drop these coordinates
- drop the name of the restaurant, because naming doesn't influence ratings
- drop address, state, fax and zip, because these features don't influence ratings 
- drop country, because all restaurants are from Mexico (irrelevant feature)

Additionaly, we conclude that in total there are 130 unique restaurants.

```{r}
# Columns
names(geoplaces2_df)
# Number of attributes
ncol(geoplaces2_df)
# Number of instances
nrow(geoplaces2_df)
# Summary
summary(geoplaces2_df, maxsum = 1000)
# Head
head(geoplaces2_df)
# Number of nulls
sum(geoplaces2_df == "?")
# Number of nulls per column
colSums(geoplaces2_df == "?")
# Number of restaurants
sprintf("There are %d unique restaurants", length(unique(geoplaces2_df$placeID)))
```

An interesting analysis is to try to understand if some of the given restaurant features affect the ratings. For that we elaborate some connected scatterplots.

```{r}
# Merge ratings and restaurants
ratings_restaurants <- merge(rating_final_df, geoplaces2_df, by = "placeID")
```

##### Feature 5.1: alcohol

```{r}
# Calculate mean rating per each type of price for general rating
mean_low_rating <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "No_Alcohol_Served"),]$rating)
mean_medium_rating <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "Full_Bar"),]$rating)
mean_high_rating <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "Wine-Beer"),]$rating)

# Calculate mean rating per each type of price for service rating
mean_low_service <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "No_Alcohol_Served"),]$service)
mean_medium_service <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "Full_Bar"),]$service)
mean_high_service <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "Wine-Beer"),]$service)

# Calculate mean rating per each type of price for food rating
mean_low_food <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "No_Alcohol_Served"),]$food)
mean_medium_food <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "Full_Bar"),]$food)
mean_high_food <- mean(ratings_restaurants[which(ratings_restaurants$alcohol == "Wine-Beer"),]$food)

# Create data:
budget <- c(0, 1, 2)
rating <- c(mean_low_rating, mean_medium_rating, mean_high_rating)
service <- c(mean_low_service, mean_medium_service, mean_high_service)
food <- c(mean_low_food, mean_medium_food, mean_high_food)

# Make a basic graph
plot(rating~budget, type="b", main="Mean rating per alcohol", bty="l", xlab="Alcohol", ylab="Mean rating", col=rgb(0.2,0.4,0.1,0.7), lwd=3, pch=17 ,ylim=c(1.0, 1.3))
lines(service~budget , col=rgb(0.8,0.4,0.1,0.7) , lwd=3 , pch=18 , type="b" )
lines(food~budget , col=rgb(0.6,0.3,0.2,0.7) , lwd=3 , pch=19 , type="b" )

# Add a legend
legend("bottomright", legend = c("Combined", "Service", "Food"), col = c(rgb(0.2,0.4,0.1,0.7), rgb(0.8,0.4,0.1,0.7), rgb(0.6,0.3,0.2,0.7)), pch = c(17,18,19), bty = "n", pt.cex = 2, cex = 1.2, text.col = "black", horiz = F , inset = c(0.1, 0.1))
```

##### Feature 5.2: smoking_are

##### Feature 5.3: dress_code

##### Feature 5.4: accessibility

##### Feature 5.5: price

From the following chart we can conclude that medium and high price restaurants have better ratings than lower price restaurants.
```{r}
# Calculate mean rating per each type of price for general rating
mean_low_rating <- mean(ratings_restaurants[which(ratings_restaurants$price == "low"),]$rating)
mean_medium_rating <- mean(ratings_restaurants[which(ratings_restaurants$price == "medium"),]$rating)
mean_high_rating <- mean(ratings_restaurants[which(ratings_restaurants$price == "high"),]$rating)

# Calculate mean rating per each type of price for service rating
mean_low_service <- mean(ratings_restaurants[which(ratings_restaurants$price == "low"),]$service)
mean_medium_service <- mean(ratings_restaurants[which(ratings_restaurants$price == "medium"),]$service)
mean_high_service <- mean(ratings_restaurants[which(ratings_restaurants$price == "high"),]$service)

# Calculate mean rating per each type of price for food rating
mean_low_food <- mean(ratings_restaurants[which(ratings_restaurants$price == "low"),]$food)
mean_medium_food <- mean(ratings_restaurants[which(ratings_restaurants$price == "medium"),]$food)
mean_high_food <- mean(ratings_restaurants[which(ratings_restaurants$price == "high"),]$food)

# Create data:
budget <- c(0, 1, 2)
rating <- c(mean_low_rating, mean_medium_rating, mean_high_rating)
service <- c(mean_low_service, mean_medium_service, mean_high_service)
food <- c(mean_low_food, mean_medium_food, mean_high_food)

# Make a basic graph
plot(rating~budget, type="b", main="Mean rating per price", bty="l", xlab="Price", ylab="Mean rating", col=rgb(0.2,0.4,0.1,0.7), lwd=3, pch=17 ,ylim=c(0.8, 1.4))
lines(service~budget , col=rgb(0.8,0.4,0.1,0.7) , lwd=3 , pch=18 , type="b" )
lines(food~budget , col=rgb(0.6,0.3,0.2,0.7) , lwd=3 , pch=19 , type="b" )

# Add a legend
legend("bottomright", legend = c("Combined", "Service", "Food"), col = c(rgb(0.2,0.4,0.1,0.7), rgb(0.8,0.4,0.1,0.7), rgb(0.6,0.3,0.2,0.7)), pch = c(17,18,19), bty = "n", pt.cex = 2, cex = 1.2, text.col = "black", horiz = F , inset = c(0.1, 0.1))
```
##### Feature 5.6: Rambience

##### Feature 5.7: franchise

##### Feature 5.8: area

##### Feature 5.9: other_services

#### Dataset 6: usercuisine

This dataset contains information about the preferred cuisine(s) type(s) for each user. It contains the following features:
- userID: corresponds to the user id;
- Rcuisine: corresponds to the type(s) of cuisine(s) that the user prefers. This is a nominal feature with 103 levels.
From this analysis we conclude that this dataset has no missing values, but a treatment to Rcuisine is necessary to reduce the number of levels of this feature. This treatment should match the one done to Rcuisine from chefmozcuisine.
```{r}
# Columns
names(usercuisine_df)
# Number of attributes
ncol(usercuisine_df)
# Number of instances
nrow(usercuisine_df)
# Summary
summary(usercuisine_df, maxsum = 1000)
# Head
head(usercuisine_df)
# Number of nulls
sum(usercuisine_df == "?")
# Number of nulls per column
colSums(usercuisine_df == "?")
# Number of levels of Rcuisine
sprintf("Rcuisine has %d levels.", nlevels(usercuisine_df$Rcuisine))
```

#### Dataset 7: userpayment

This dataset contains information about the payment methods that users prefers. It contains the following features:
- userID: corresponds to the user id;
- Upayment: corresponds to the type of payment that the user prefers. This is a nominal feature with 5 levels.
From this analysis we conclude that this dataset has no missing values, but a treatment to Upayment is necessary to reduce the number of levels of this feature, and it should match the treatment made to chefmozaccepts.
```{r}
# Columns
names(userpayment_df)
# Number of attributes
ncol(userpayment_df)
# Number of instances
nrow(userpayment_df)
# Summary
summary(userpayment_df, maxsum = 1000)
# Head
head(userpayment_df)
# Number of nulls
sum(userpayment_df == "?")
# Number of nulls per column
colSums(userpayment_df == "?")
# Number of levels of Rpayment
sprintf("Upayment has %d levels.", nlevels(userpayment_df$Upayment))
```

##### Feature 7.1: Upayment

A graphical visualization with a barplot shows the distribution of this feature.
```{r}
upayment <- unique(userpayment_df$Upayment)
title <- "Total users per payment type"
xlab <- "UPayment"
ylab <- "User count"
feature <- "Upayment"
drawBarplot(userpayment_df, upayment, title, xlab, ylab, feature)
```

#### Dataset 8: userprofile

This dataset contains information about the users that rated the restaurants. It contains the following features:
- userID: corresponds to the user id;
- latitude and longitude: correspond to the geospatial coordinates of the user These are both numeric features;
- smoker: indicates whether the user is smoker or not. This is a nominal feature with 2 levels and 3 missing values;
- drink_level: indicates the drink level of the user. This is a nominal feature with 3 levels;
- dress_preference: indicates the user's dress preference. This is a nominal feature with 4 levels and 5 missing values;
- ambience: indicates the ambience that the user prefers. This is a nominal feature with 3 levels and 6 missing values;
- transport: indicates the kind of transportation that the user prefers. This is a nominal feature with 3 levels and 7 missing values;
- marital_status: indicates the marital status of the user. This is a nominal feature with 3 levels and 4 missing values;
- hijos: indicates wheter the user has kids or not. This is a nominal feature with 3 levels and 11 missing values;
- birth_year: user birth year. This is a numeric feature.
- interest: indicates user's interest. This is a nominal feature with 5 levels;
- personality: indicates user's personality. This is a nominal feature with 4 levels;
- religion: indicates user's religion. This is a nominal feature with 5 levels;
- activity: indicates user's activity. This is a nominal feature with 4 levels and 7 missing values;
- color: indicates user's color preference. This is a nominal feature with 8 levels;
- weight: user's weight (numeric);
- budget: indicates user's budget. This is a nominal feature with 3 levels and 7 missing values;
- height: user's height (numeric).

From this analysis we conclude that this dataset needs the following treatments:
- discover the user cities to match the restaurant cities with the given latitute and longitude, and then drop these coordinates
- treat smoker missing values
- treat dress_preference missing values
- treat ambience missing values
- treat transport missing values
- treat marital_status missing values
- treat hijos missing values
- treat activity missing values
- treat budget missing values

Additionaly, we conclude that in total there are 138 unique users.
```{r}
# Columns
names(userprofile_df)
# Number of attributes
ncol(userprofile_df)
# Number of instances
nrow(userprofile_df)
# Summary
summary(userprofile_df, maxsum = 1000)
# Head
head(userprofile_df)
# Number of nulls
sum(userprofile_df == "?")
# Number of nulls per column
colSums(userprofile_df == "?")
# Number of users
sprintf("There are %d unique users", length(unique(userprofile_df$userID)))

```

Graphical visualization:

##### Feature 8.1: smoker
```{r}
smoker_type <- c("true", "false", "?")
title <- "Total of users by smoker type"
xlab <- "Smoker type"
ylab <- "User count"
feature <- "smoker"
drawBarplot(userprofile_df, smoker_type, title, xlab, ylab, feature)
```

##### Feature 8.2: drink_level
```{r}
drink_level_type <- c("abstemious", "casual drinker", "social drinker")
title <- "Total users per drink level"
xlab <- "Drink level"
ylab <- "User count"
feature <- "drink_level"
drawBarplot(userprofile_df, drink_level_type, title, xlab, ylab, feature)
```

##### Feature 8.3: dress_preference
```{r}
dress_preference_type <- c("elegant", "formal", "informal", "no preference", "?")
title <- "Total users per dress preference"
xlab <- "Dress Preference"
ylab <- "User count"
feature <- "dress_preference"
drawBarplot(userprofile_df, dress_preference_type, title, xlab, ylab, feature)
```

##### Feature 8.4: ambience
```{r}
ambience_type <- c("family", "friends", "solitary", "?")
title <- "Total users per dress ambience"
xlab <- "Ambience"
ylab <- "User count"
feature <- "ambience"
drawBarplot(userprofile_df, ambience_type, title, xlab, ylab, feature)
```

##### Feature 8.5: transport
```{r}
transport_type <- c("car owner", "on foot", "public", "?")
title <- "Total users per transport type"
xlab <- "Transport"
ylab <- "User count"
feature <- "transport"
drawBarplot(userprofile_df, transport_type, title, xlab, ylab, feature)
```

##### Feature 8.6: marital_status
```{r}
marital_status <- c("married", "single", "widow", "?")
title <- "Total users per marital status"
xlab <- "Marital Status"
ylab <- "User count"
feature <- "marital_status"
drawBarplot(userprofile_df, marital_status, title, xlab, ylab, feature)
```

##### Feature 8.7: hijos
```{r}
hijos <- c("dependent", "independent", "kids", "?")
title <- "Total users per children"
xlab <- "Children"
ylab <- "User count"
feature <- "hijos"
drawBarplot(userprofile_df, hijos, title, xlab, ylab, feature)
```

##### Feature 8.8: interest
```{r}
interest <- c("eco-friendly", "none", "retro", "technology", "variety", "?")
title <- "Total users per interest"
xlab <- "Interest"
ylab <- "User count"
feature <- "interest"
drawBarplot(userprofile_df, interest, title, xlab, ylab, feature)
```

##### Feature 8.9: personality
```{r}
personality <- c("conformist", "hard-worker", "hunter-ostentatious", "thrifty-protector", "?")
title <- "Total users per personality"
xlab <- "Personality"
ylab <- "User count"
feature <- "personality"
drawBarplot(userprofile_df, personality, title, xlab, ylab, feature)
```

##### Feature 8.10: religion
```{r}
religion <- c("Catholic", "Christian", "Jewish", "Mormon", "none", "?")
title <- "Total users per religion"
xlab <- "Religion"
ylab <- "User count"
feature <- "religion"
drawBarplot(userprofile_df, religion, title, xlab, ylab, feature)
```

##### Feature 8.11: activity
```{r}
activity <- c("professional", "student", "unemployed", "working-class", "?")
title <- "Total users per activity"
xlab <- "Activity"
ylab <- "User count"
feature <- "activity"
drawBarplot(userprofile_df, activity, title, xlab, ylab, feature)
```

##### Feature 8.12: color
```{r}
color <- c("black", "blue", "green", "orange", "purple", "red", "white", "yellow", "?")
title <- "Total users per color"
xlab <- "Color"
ylab <- "User count"
feature <- "color"
drawBarplot(userprofile_df, color, title, xlab, ylab, feature)
```

##### Feature 8.13: budget
```{r}
budget_type <- c("hight", "low", "medium", "?")
title <- "Total users per budget type"
xlab <- "Budget"
ylab <- "User count"
feature <- "budget"
drawBarplot(userprofile_df, budget_type, title, xlab, ylab, feature)
```

#### Dataset 9: rating_final
```{r}
# Columns
names(rating_final_df)
# Number of attributes
ncol(rating_final_df)
# Number of instances
nrow(rating_final_df)
# Summary
summary(rating_final_df, maxsum = 1000)
# Head
head(rating_final_df)
# Number of nulls
sum(rating_final_df == "?")
# Number of nulls per column
colSums(rating_final_df == "?")
```

## Data Preparation

#### Dataset 1: chefmozaccepts

As observed in Data Understanding, this dataset has an attribute (Rpayment) that has 12 levels. An important treatment to this feature is to reduce the amount of levels. The same problem exists in userpayment dataframe, but instead this one has XXXXXX levels. To accommodate the treatment for both datasets, the following levels will be created and used (instead of the originals presented in the datasets):

1. Card 
  - American_Express, bank_debit_cards, Carte_Blanche, Visa, VISA, MasterCard-Eurocard
2. Cash
  - cash
3. Other
  - checks, Diners_Club, Discover, gift_certificates, Japan_Credit_Bureau, 

```{r}
# Define auxiliar function to calculate Rpayment
calculateRpayment <- function(dataset) {
  dataset$payment <- c("")
  
  # Compute new payment types
  for(i in seq_len(nrow(dataset))) {
    payment <- as.character(dataset[i,2])
    if(payment == "American_Express" || payment == "bank_debit_cards" || payment == "Carte_Blanche" || payment == "Visa" || payment == "VISA" || payment == "MasterCard-Eurocard") {
      dataset[i,3] <- "Card"
    } else if(payment == "cash") {
      dataset[i,3] <- "Cash"
    } else {
      dataset[i,3] <- "Other"
    }
  }
  # Transform Rpayment to calculated values as factor
  dataset[,2] <- as.factor(dataset$payment)
  return(dataset)
}
```

This feature started with the following information:
```{r}
summary(chefmozaccepts_df$Rpayment)
```

So it's expected that it ends with:
  - 153 (American_Express) + 130 (bank_debit_cards) + 7 (Carte_Blanche) + 83 (Visa) + 172 (VISA) + 194 (MasterCard-Eurocard) = 739 (Card)
  - 500 (Cash)
  - 10 (checks) + 42 (Diners_Club) + 11 (Discover) + 7 (gift_certificates) + 5 (Japan_Credit_Bureau) = 75 (Other)
  
```{r}
# Calculate new Rpayment types
chefmozaccepts_df <- calculateRpayment(chefmozaccepts_df)

# Drop unnecessary column
chefmozaccepts_df <- chefmozaccepts_df[,c("placeID", "Rpayment")]

summary(chefmozaccepts_df$Rpayment)
```

#### Datset 2: chefmozcuisine

As observed in Data Understanding, this dataset has an attribute (Rcuisine) that has 59 levels. An important treatment to this feature is to reduce the amount of levels. The same problem exists in usercuisine dataframe, but instead this one has 103 levels. To accommodate the treatment for both datasets, the following levels will be created and used (instead of the originals presented in the datasets):

1. Bar/Cafeteria 
  - Bagels, Bakery, Bar, Bar_Pub_Brewery, Breakfast-Brunch, Cafe-Coffee_Shop, Cafeteria, Deli-Sandwiches, Dessert-Ice_Cream, Doughnuts, Juice
2. Mexican
  - Mexican, Regional, Tex-Mex
3. Asian
  - Asian, Cambodian, Chinese, Dim_Sum, Filipino, Japanese, Korean, Malaysian, Mongolian, Sushi, Thai, Tibetan, Vietnamese
4. Internationl (others)
  - Afghan, African, American, Armenian, Barbecue, Brazilian, Burgers, California, Caribbean, Contemporary, Continental-European, Diner, Dutch-Belgian, Eastern_European, Ethiopian, Family, Fast_Food, Fine_Dining, French, Game, German, Greek, Hot_Dogs, International, Italian, Latin_American, Mediterranean, Organic-Healthy, Persian, Pizzeria, Polish, Seafood, Soup, Southern, Southwestern, Spanish, Steaks, Turkish, Vegetarian

```{r}
# Define auxiliar function to calculate Rcuisine
calculateRcuisine <- function(dataset) {
  dataset$cuisine <- c("")
  # Compute new cuisine types
  for(i in seq_len(nrow(dataset))) {
    cuisine <- as.character(dataset[i,2])
    if(cuisine == "Bagels" || cuisine == "Bakery" || cuisine == "Bar" || cuisine == "Bar_Pub_Brewery" || cuisine == "Breakfast-Brunch" || cuisine == "Cafe-Coffee_Shop" || cuisine == "Cafeteria" || cuisine == "Deli-Sandwiches" || cuisine == "Dessert-Ice_Cream" || cuisine == "Doughnuts" || cuisine == "Juice") {
      dataset[i,3] <- "Bar/Cafeteria"
    } else if(cuisine == "Mexican" || cuisine == "Regional" || cuisine == "Tex-Mex") {
      dataset[i,3] <- "Mexican"
    } else if(cuisine == "Asian" || cuisine == "Cambodian" || cuisine == "Chinese" || cuisine == "Dim_Sum" || cuisine == "Filipino" || cuisine == "Japanese" || cuisine == "Korean" || cuisine == "Malaysian" || cuisine == "Mongolian" || cuisine == "Sushi" || cuisine == "Thai" || cuisine == "Tibetan" || cuisine == "Vietnamese") {
      dataset[i,3] <- "Asian"
    } else {
      dataset[i,3] <- "International"
    }
  }
  # Transform Rcuisine to calculated values as factor
  dataset[,2] <- as.factor(dataset$cuisine)
  return(dataset)
}
```

```{r}
# Calculate new Rcuisine types
chefmozcuisine_df <- calculateRcuisine(chefmozcuisine_df)

# Drop unnecessary column
chefmozcuisine_df <- chefmozcuisine_df[,c("placeID", "Rcuisine")]
```

#### Dataset 3: chefmozhours4

#### Dataset 4: chefmozparking

As discussed in Data Undestarnding, no treatment will be applied to this dataset.

#### Dataset 5: geoplaces2

Select only relevant features.
Treat missing hours and create relevant features.

```{r}
rest_df <- geoplaces2_df[,c("placeID", "latitude", "longitude", "city", "alcohol", 
                            "smoking_area", "dress_code", "accessibility", "price", "Rambience",
                            "franchise", "area", "other_services")]

rest_st_df <- chefmozhours4_df[which(chefmozhours4_df$days == "Sat;"),]

rest_sd_df <- chefmozhours4_df[which(chefmozhours4_df$days == "Sun;"),]
rest_wk_df <- chefmozhours4_df[which(chefmozhours4_df$days == "Mon;Tue;Wed;Thu;Fri;"),]

rest_days_df <- merge(rest_st_df, rest_sd_df, by = "placeID")
rest_days_df <- merge(rest_days_df, rest_wk_df, by = "placeID")

setnames(rest_days_df, old=c("hours.x","hours.y","hours"), new=c("st", "sd","wk"))

rest_days_df <- rest_days_df[,c("placeID", "st", "sd","wk")]

rest_days_df <- rest_days_df[!duplicated(rest_days_df[c("placeID", "st", "sd","wk")]),]

rest_days_df <- data.frame(lapply(rest_days_df, as.character), stringsAsFactors = FALSE)
  
restaurant_df <- merge(rest_df, rest_days_df, by = "placeID", all.x = TRUE)

for(placeID in unique(restaurant_df$placeID)) {
  test <- restaurant_df[which(restaurant_df$placeID == placeID),]
  if(is.element("00:00-00:00;", test$st)){
    #Closed restaurant
    restaurant_df[which(restaurant_df$placeID == placeID),]$st <- 0
  } else {
    #Open restaurant (the Na will considered "open")
    restaurant_df[which(restaurant_df$placeID == placeID),]$st <- 1
  }
}

for(placeID in unique(restaurant_df$placeID)) {
  test <- restaurant_df[which(restaurant_df$placeID == placeID),]
  if(is.element("00:00-00:00;", test$sd)){
    #Closed restaurant
    restaurant_df[which(restaurant_df$placeID == placeID),]$sd <- 0
  } else {
    #Open restaurant (the Na will considered "open")
    restaurant_df[which(restaurant_df$placeID == placeID),]$sd <- 1
  }
}

for(placeID in unique(restaurant_df$placeID)) {
  test <- restaurant_df[which(restaurant_df$placeID == placeID),]
  if(is.element("00:00-00:00;", test$st)){
    #Closed restaurant
    restaurant_df[which(restaurant_df$placeID == placeID),]$wk <- 0
  } else {
    #Open restaurant (the Na will considered "open")
    restaurant_df[which(restaurant_df$placeID == placeID),]$wk <- 1
  }
}

geoplaces2_df <- restaurant_df
```

#### Dataset 6: usercuisine

As discussed in Data Understanding section, a treatment to Rcuisine will be applied.

```{r}
sprintf("Rcuisine has %d levels.", nlevels(usercuisine_df$Rcuisine))

# Calculate new RCuisine types
usercuisine_df <- calculateRcuisine(usercuisine_df)

# Drop unnecessary column
usercuisine_df <- usercuisine_df[,c("userID", "Rcuisine")]
```

#### Dataset 7: userpayment

As discussed in Data Understanding, a treatment to Ucuisine will be applied.

This feature started with the following information:
```{r}
summary(userpayment_df$Upayment)
```

So it's expected that it ends with:
  - 3 (American_Express) + 22 (bank_debit_cards) + 17 (VISA) + 4 (MasterCard-Eurocard) = 46 (Card)
  - 131 (Cash)

```{r}
# Calculate new Upayment types
userpayment_df <- calculateRpayment(userpayment_df)

# Drop unnecessary column
userpayment_df <- userpayment_df[,c("userID", "Upayment")]

summary(userpayment_df$Upayment)
```

#### Dataset 8: userprofile

```{r}
sprintf("As seen in Data Understanding phase, userprofile dataset has %d missing values. The columns with missing values are 'smoker', 'ambience', 'transport', 'marital_status', 'hijos', 'activity' and 'budget'.", sum(userprofile_df == "?"))
```

'smoker' column:
```{r}
sprintf("1. 'smoker' column (nominal) has %d missing values, where %d are 'true' and %d are 'false. This means that the mode for this column is 'true'. In this case, and because it's preferrable to put a smoker person in a non-smoking restaurant than a non-smoker in a smoker restaurant, we will impute the missing values with 'true'.", sum(userprofile_df$smoker == "?"), sum(userprofile_df$smoker == 'true'), sum(userprofile_df$smoker == 'false'))

# Force NA's
userprofile_df[which(userprofile_df$smoker=="?"),]$smoker <- NA
length(which(is.na(userprofile_df$smoker)))
# Calculate mode
smoker_mode <- calculateMode(na.omit(userprofile_df$smoker))
smoker_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "smoker", Value=smoker_mode)
print(summary(userprofile_df$smoker))
```

'dress_preference' column:
This column has 5 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$dress_preference=="?"),]$dress_preference <- NA
length(which(is.na(userprofile_df$dress_preference)))
# Calculate mode
dress_preference_mode <- calculateMode(na.omit(userprofile_df$dress_preference))
dress_preference_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "dress_preference", Value=dress_preference_mode)
print(summary(userprofile_df$dress_preference))
```

'ambience' column:
This column has 6 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$ambience=="?"),]$ambience <- NA
length(which(is.na(userprofile_df$ambience)))
# Calculate mode
ambience_mode <- calculateMode(na.omit(userprofile_df$ambience))
ambience_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "ambience", Value=ambience_mode)
print(summary(userprofile_df$ambience))
```

'transport' column:
This column has 7 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$transport=="?"),]$transport <- NA
length(which(is.na(userprofile_df$transport)))
# Calculate mode
transport_mode <- calculateMode(na.omit(userprofile_df$transport))
transport_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "transport", Value=transport_mode)
print(summary(userprofile_df$transport))
```

'marital_status' column:
This column has 4 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$marital_status=="?"),]$marital_status <- NA
length(which(is.na(userprofile_df$marital_status)))
# Calculate mode
marital_status_mode <- calculateMode(na.omit(userprofile_df$marital_status))
marital_status_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "marital_status", Value=marital_status_mode)
print(summary(userprofile_df$marital_status))
```

'hijos' column:
This column has 11 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$hijos=="?"),]$hijos <- NA
length(which(is.na(userprofile_df$hijos)))
# Calculate mode
hijos_mode <- calculateMode(na.omit(userprofile_df$hijos))
hijos_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "hijos", Value=hijos_mode)
print(summary(userprofile_df$hijos))
```

'activity' column:
This column has 7 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$activity=="?"),]$activity <- NA
length(which(is.na(userprofile_df$activity)))
# Calculate mode
activity_mode <- calculateMode(na.omit(userprofile_df$activity))
activity_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "activity", Value=activity_mode)
print(summary(userprofile_df$activity))
```

'budget' column:
This column has 7 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$budget=="?"),]$budget <- NA
length(which(is.na(userprofile_df$budget)))
# Calculate mode
budget_mode <- calculateMode(na.omit(userprofile_df$budget))
budget_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "budget", Value=budget_mode)
print(summary(userprofile_df$budget))
```

#### Dataset 9: rating_final

As discussed in Data Understanding, this dataset doesn't need any treatment.

To be able to use all the relevant features in the model, we need to create a dataframe with them.
```{r}
# Join dataframes
final_df <- merge(rating_final_df, chefmozaccepts_df, by = "placeID")
final_df <- merge(final_df, chefmozcuisine_df, by = "placeID")
final_df <- merge(final_df, chefmozhours4_df, by = "placeID")
final_df <- merge(final_df, chefmozparking_df, by = "placeID")
final_df <- merge(final_df, geoplaces2_df, by = "placeID")
final_df <- merge(final_df, usercuisine_df, by = "userID")
final_df <- merge(final_df, userpayment_df, by = "userID")
final_df <- merge(final_df, userprofile_df, by = "userID")

# Rename a column in R
colnames(final_df)[colnames(final_df)=="Rcuisine.x"] <- "Rcuisine"
colnames(final_df)[colnames(final_df)=="Rcuisine.y"] <- "UserRcuisine"

# Analyze final dataframe
# Columns
names(final_df)
# Number of attributes
ncol(final_df)
# Number of instances
nrow(final_df)
# Summary
summary(final_df)
# Head
head(final_df)
# Number of nulls
sum(final_df == "?")
# Number of nulls per column
colSums(final_df == "?")

# Drop unnecessary columns
final_df <- final_df[,c("rating","Rpayment", "days", "parking_lot", "Upayment", "smoker", "drink_level", "dress_preference", "ambience", "transport", "marital_status", "hijos", "interest", "personality", "religion", "activity", "color", "budget")]

# Dropped columns: userID, placeID, food_rating, service_rating, latitude, longitude, birth_year, weight, height, hours, UserRcuisine, Rcuisine
```

## Modeling

The main goal for this project is to predict the ratings that would be given by each customer for the restaurants that he/she didn't rate. In Data Understanding we saw that ratings are numerical values, so predicting their values can be treated as a regression problem. Using classification techniques is also reasonable since the possible ratings are three discrete integers: 0, 1 and 2.


### Holdout
As this is a supervised learning problem, the first step is to select the training and test datasets.
We will use the holdout technique.

```{r}

summary(final_df)
H = holdout(final_df$rating, ratio = 0.8)
```

### Neuronal Network

```{r}
?fit
Fi <- fit(rating~., final_df[H$tr,], model = "mlp")

P <- predict(Fi, final_df[H$ts,])

mmetric(final_df[H$ts,]$rating, P, metric = "MAE")
mmetric(final_df[H$ts,]$rating, P, metric = "MAPE")
```

## Evaluation

## Deployment

This step will not be executed.

# Bibliography

https://www.kaggle.com/liyenhsu/simple-content-based-recommenders

Get mode: https://www.tutorialspoint.com/r/r_mean_median_mode.htm





