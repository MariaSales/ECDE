---
title: "Restaurante and consumer data"
output: html_notebook
---

## ECDE - 2nd Semestre 2017/18

<b>Group 2:</b><br />
Alessandro Fragal√† N 84080<br />
Anderson Acosta N 81799<br />
Maria Sales N 83748<br />

The selected dataset for this project is ["Restaurante and consumer data"](https://archive.ics.uci.edu/ml/datasets/Restaurant+%26+consumer+data#), which was extracted from the UCI Machine Learning Repository.
This dataset contains nine csv files: five of them have Restaurant categories, three have consumer categories and the last one contains ratings.

#### Library installation
```{r}
install.packages("rminer")
library(rminer)
library(data.table)
```
#### Auxiliar functions
```{r}
# Calculate mode
calculateMode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Draw barplot
drawBarplot <- function(dataframe, type, title, xlab, ylab, feature) {
  count <- c()
  for(s in type) {
    value <- length(dataframe[which(dataframe[,feature] == s),feature])
    count <- c(count, value) # append to the end
  }
  bb <- barplot(count, main = title, xlab = xlab, ylab = ylab, names.arg = type, ylim = c(0, max(count) + 10))
  text(x = bb, y = count, labels = count, pos = 3)
}
```

## Business Undestanding

The main purpose for this project is to "generate a top-n list of restaurants according to the consumer preferences". 

## Data Understanding

First step is to read all the datasets
```{r}
# Set workspace
setwd("/Users/mariasales/Desktop/MIG/1A2A/ECDE/Trabalho")

# Read datasets
#Restaurants
chefmozaccepts_df <- read.csv("chefmozaccepts.csv")
chefmozcuisine_df <- read.csv("chefmozcuisine.csv")
chefmozhours4_df <- read.csv("chefmozhours4.csv")
chefmozparking_df <- read.csv("chefmozparking.csv")
geoplaces2_df <- read.csv("geoplaces2.csv",encoding='latin-1')
#Consumers 
usercuisine_df <- read.csv("usercuisine.csv")
userpayment_df <- read.csv("userpayment.csv")
userprofile_df <- read.csv("userprofile.csv")
#User-Item-Rating
rating_final_df <- read.csv("rating_final.csv")
```

Then we want to analyze the imported data, as see some important statistics about all files:

#### chefmozaccepts
```{r}
# Columns
names(chefmozaccepts_df)
# Number of attributes
ncol(chefmozaccepts_df)
# Number of instances
nrow(chefmozaccepts_df)
# Summary
summary(chefmozaccepts_df, maxsum = 1000)
# Head
head(chefmozaccepts_df)
# Number of nulls
sum(chefmozaccepts_df == "?")
# Number of nulls per column
colSums(chefmozaccepts_df == "?")
```

Graphical visualization:

1. Feature 'Rpayment'
```{r}
rpayment <- c("American_Express", "bank_debit_cards", "Carte_Blanche", "cash", "checks", "Diners_Club", "Discover", "gift_certificates", "Japan_Credit_Bureau", "MasterCard-Eurocard", "VISA", "VISA")
title <- "Total of users by Rpayment"
xlab <- "RPayment"
ylab <- "User count"
feature <- "Rpayment"
drawBarplot(chefmozaccepts_df, rpayment, title, xlab, ylab, feature)
```

#### chefmozcuisine
```{r}
# Columns
names(chefmozcuisine_df)
# Number of attributes
ncol(chefmozcuisine_df)
# Number of instances
nrow(chefmozcuisine_df)
# Summary
summary(chefmozcuisine_df, maxsum = 1000)
# Head
head(chefmozcuisine_df)
# Number of nulls
sum(chefmozcuisine_df == "?")
# Number of nulls per column
colSums(chefmozcuisine_df == "?")
```

#### chefmozhours4
```{r}
# Columns
names(chefmozhours4_df)
# Number of attributes
ncol(chefmozhours4_df)
# Number of instances
nrow(chefmozhours4_df)
# Summary
summary(chefmozhours4_df, maxsum = 1000)
# Head
head(chefmozhours4_df)
# Number of nulls
sum(chefmozhours4_df == "?")
# Number of nulls per column
colSums(chefmozhours4_df == "?")
```

#### chefmozparking
```{r}
# Columns
names(chefmozparking_df)
# Number of attributes
ncol(chefmozparking_df)
# Number of instances
nrow(chefmozparking_df)
# Summary
summary(chefmozparking_df, maxsum = 1000)
# Head
head(chefmozparking_df)
# Number of nulls
sum(chefmozparking_df == "?")
# Number of nulls per column
colSums(chefmozparking_df == "?")
```

#### geoplaces2
```{r}
# Columns
names(geoplaces2_df)
# Number of attributes
ncol(geoplaces2_df)
# Number of instances
nrow(geoplaces2_df)
# Summary
summary(geoplaces2_df, maxsum = 1000)
# Head
head(geoplaces2_df)
# Number of nulls
sum(geoplaces2_df == "?")
# Number of nulls per column
colSums(geoplaces2_df == "?")
```

Graphical visualization:

```{r}
user_ratings <- merge(rating_final_df, geoplaces2_df, by = "placeID")

mean_low_rating <- mean(user_ratings[which(user_ratings$price == "low"),]$rating)
mean_medium_rating <- mean(user_ratings[which(user_ratings$price == "medium"),]$rating)
mean_high_rating <- mean(user_ratings[which(user_ratings$price == "high"),]$rating)

mean_low_service <- mean(user_ratings[which(user_ratings$price == "low"),]$service)
mean_medium_service <- mean(user_ratings[which(user_ratings$price == "medium"),]$service)
mean_high_service <- mean(user_ratings[which(user_ratings$price == "high"),]$service)

mean_low_food <- mean(user_ratings[which(user_ratings$price == "low"),]$food)
mean_medium_food <- mean(user_ratings[which(user_ratings$price == "medium"),]$food)
mean_high_food <- mean(user_ratings[which(user_ratings$price == "high"),]$food)

# Create data:
budget <- c(0, 1, 2)
rating <- c(mean_low_rating, mean_medium_rating, mean_high_rating)
service <- c(mean_low_service, mean_medium_service, mean_high_service)
food <- c(mean_low_food, mean_medium_food, mean_high_food)

# Make a basic graph
plot(rating~budget, type="b", main="Mean rating per price", bty="l", xlab="Price", ylab="Mean rating", col=rgb(0.2,0.4,0.1,0.7), lwd=3, pch=17 ,ylim=c(0.8, 1.4))
lines(service~budget , col=rgb(0.8,0.4,0.1,0.7) , lwd=3 , pch=18 , type="b" )
lines(food~budget , col=rgb(0.6,0.3,0.2,0.7) , lwd=3 , pch=19 , type="b" )

# Add a legend
legend("bottomright", legend = c("Combined", "Service", "Food"), col = c(rgb(0.2,0.4,0.1,0.7), rgb(0.8,0.4,0.1,0.7), rgb(0.6,0.3,0.2,0.7)), pch = c(17,18,19), bty = "n", pt.cex = 2, cex = 1.2, text.col = "black", horiz = F , inset = c(0.1, 0.1))
```

#### usercuisine
```{r}
# Columns
names(usercuisine_df)
# Number of attributes
ncol(usercuisine_df)
# Number of instances
nrow(usercuisine_df)
# Summary
summary(usercuisine_df, maxsum = 1000)
# Head
head(usercuisine_df)
# Number of nulls
sum(usercuisine_df == "?")
# Number of nulls per column
colSums(usercuisine_df == "?")
```

#### userpayment
```{r}
# Columns
names(userpayment_df)
# Number of attributes
ncol(userpayment_df)
# Number of instances
nrow(userpayment_df)
# Summary
summary(userpayment_df, maxsum = 1000)
# Head
head(userpayment_df)
# Number of nulls
sum(userpayment_df == "?")
# Number of nulls per column
colSums(userpayment_df == "?")
```

#### userprofile
```{r}
# Columns
names(userprofile_df)
# Number of attributes
ncol(userprofile_df)
# Number of instances
nrow(userprofile_df)
# Summary
summary(userprofile_df, maxsum = 1000)
# Head
head(userprofile_df)
# Number of nulls
sum(userprofile_df == "?")
# Number of nulls per column
colSums(userprofile_df == "?")
```

Graphical visualization:

1. Feature 'smoker'
```{r}
smoker_type <- c("true", "false", "?")
title <- "Total of users by smoker type"
xlab <- "Smoker type"
ylab <- "User count"
feature <- "smoker"
drawBarplot(userprofile_df, smoker_type, title, xlab, ylab, feature)
```

2. Feature 'drink_level'
```{r}
drink_level_type <- c("abstemious", "casual drinker", "social drinker")
title <- "Total users per drink level"
xlab <- "Drink level"
ylab <- "User count"
feature <- "drink_level"
drawBarplot(userprofile_df, drink_level_type, title, xlab, ylab, feature)
```

3. Feature 'dress_preference'
```{r}
dress_preference_type <- c("elegant", "formal", "informal", "no preference", "?")
title <- "Total users per dress preference"
xlab <- "Dress Preference"
ylab <- "User count"
feature <- "dress_preference"
drawBarplot(userprofile_df, dress_preference_type, title, xlab, ylab, feature)
```

4. Feature 'ambience'
```{r}
ambience_type <- c("family", "friends", "solitary", "?")
title <- "Total users per dress ambience"
xlab <- "Ambience"
ylab <- "User count"
feature <- "ambience"
drawBarplot(userprofile_df, ambience_type, title, xlab, ylab, feature)
```

5. Feature 'transport'
```{r}
transport_type <- c("car owner", "on foot", "public", "?")
title <- "Total users per transport type"
xlab <- "Transport"
ylab <- "User count"
feature <- "transport"
drawBarplot(userprofile_df, transport_type, title, xlab, ylab, feature)
```

6. Feature 'marital_status'
```{r}
marital_status <- c("married", "single", "widow", "?")
title <- "Total users per marital status"
xlab <- "Marital Status"
ylab <- "User count"
feature <- "marital_status"
drawBarplot(userprofile_df, marital_status, title, xlab, ylab, feature)
```

7. Feature 'hijos'
```{r}
hijos <- c("dependent", "independent", "kids", "?")
title <- "Total users per children"
xlab <- "Children"
ylab <- "User count"
feature <- "hijos"
drawBarplot(userprofile_df, hijos, title, xlab, ylab, feature)
```

8. Feature 'interest'
```{r}
interest <- c("eco-friendly", "none", "retro", "technology", "variety", "?")
title <- "Total users per interest"
xlab <- "Interest"
ylab <- "User count"
feature <- "interest"
drawBarplot(userprofile_df, interest, title, xlab, ylab, feature)
```

9. Feature 'personality'
```{r}
personality <- c("conformist", "hard-worker", "hunter-ostentatious", "thrifty-protector", "?")
title <- "Total users per personality"
xlab <- "Personality"
ylab <- "User count"
feature <- "personality"
drawBarplot(userprofile_df, personality, title, xlab, ylab, feature)
```

10. Feature 'religion'
```{r}
religion <- c("Catholic", "Christian", "Jewish", "Mormon", "none", "?")
title <- "Total users per religion"
xlab <- "Religion"
ylab <- "User count"
feature <- "religion"
drawBarplot(userprofile_df, religion, title, xlab, ylab, feature)
```

11. Feature 'activity'
```{r}
activity <- c("professional", "student", "unemployed", "working-class", "?")
title <- "Total users per activity"
xlab <- "Activity"
ylab <- "User count"
feature <- "activity"
drawBarplot(userprofile_df, activity, title, xlab, ylab, feature)
```

12. Feature 'color'
```{r}
color <- c("black", "blue", "green", "orange", "purple", "red", "white", "yellow", "?")
title <- "Total users per color"
xlab <- "Color"
ylab <- "User count"
feature <- "color"
drawBarplot(userprofile_df, color, title, xlab, ylab, feature)
```

13. Feature 'budget'
```{r}
budget_type <- c("hight", "low", "medium", "?")
title <- "Total users per budget type"
xlab <- "Budget"
ylab <- "User count"
feature <- "budget"
drawBarplot(userprofile_df, budget_type, title, xlab, ylab, feature)
```

#### rating_final
```{r}
# Columns
names(rating_final_df)
# Number of attributes
ncol(rating_final_df)
# Number of instances
nrow(rating_final_df)
# Summary
summary(rating_final_df, maxsum = 1000)
# Head
head(rating_final_df)
# Number of nulls
sum(rating_final_df == "?")
# Number of nulls per column
colSums(rating_final_df == "?")
```

#### Exploratory visualization

TODO!

#### Conclusion
```{r}
sprintf("There are %d unique users and %d unique restaurants", length(unique(userprofile_df$userID)), length(unique(geoplaces2_df$placeID)))
```

## Data Preparation

#### chefmozaccepts

#### chefmozcuisine

As observed in Data Understanding, this dataset has an attribute (Rcuisine) which has 59 levels. An important treatment to this feature is to reduce the amount of levels. The same problem exists in usercuisine dataframe, but instead this one has 103 levels. To accommodate the treatment for both datasets, the following levels will be created and used (instead of the originals presented in the datasets):

1. Bar/Cafeteria 
  - Bagels, Bakery, Bar, Bar_Pub_Brewery, Breakfast-Brunch, Cafe-Coffee_Shop, Cafeteria, Deli-Sandwiches, Dessert-Ice_Cream, Doughnuts, Juice      
2. Mexican
  - Mexican, Regional, Tex-Mex
3. Asian
  - Asian, Cambodian, Chinese, Dim_Sum, Filipino, Japanese, Korean, Malaysian, Mongolian, Sushi, Thai, Tibetan, Vietnamese
4. Internationl (others)
  - Afghan, African, American, Armenian, Barbecue, Brazilian, Burgers, California, Caribbean, Contemporary, Continental-European, Diner, Dutch-Belgian, Eastern_European, Ethiopian, Family, Fast_Food, Fine_Dining, French, Game, German, Greek, Hot_Dogs, International, Italian, Latin_American, Mediterranean, Organic-Healthy, Persian, Pizzeria, Polish, Seafood, Soup, Southern, Southwestern, Spanish, Steaks, Turkish, Vegetarian

```{r}
# Define auxiliar function to calculate Rcuisine
calculateRcuisine <- function(dataset) {
  dataset$cuisine <- c("")
  # Compute new cuisine types
  for(i in seq_len(nrow(dataset))) {
    cuisine <- as.character(dataset[i,2])
    if(cuisine == "Bagels" || cuisine == "Bakery" || cuisine == "Bar" || cuisine == "Bar_Pub_Brewery" || cuisine == "Breakfast-Brunch" || cuisine == "Cafe-Coffee_Shop" || cuisine == "Cafeteria" || cuisine == "Deli-Sandwiches" || cuisine == "Dessert-Ice_Cream" || cuisine == "Doughnuts" || cuisine == "Juice") {
      dataset[i,3] <- "Bar/Cafeteria"
    } else if(cuisine == "Mexican" || cuisine == "Regional" || cuisine == "Tex-Mex") {
      dataset[i,3] <- "Mexican"
    } else if(cuisine == "Asian" || cuisine == "Cambodian" || cuisine == "Chinese" || cuisine == "Dim_Sum" || cuisine == "Filipino" || cuisine == "Japanese" || cuisine == "Korean" || cuisine == "Malaysian" || cuisine == "Mongolian" || cuisine == "Sushi" || cuisine == "Thai" || cuisine == "Tibetan" || cuisine == "Vietnamese") {
      dataset[i,3] <- "Asian"
    } else {
      dataset[i,3] <- "International"
    }
  }
  # Transform Rcuisine to calculated values as factor
  dataset$Rcuisine <- as.factor(dataset$cuisine)
  return(dataset)
}
```

```{r}
sprintf("Rcuisine has %d levels.", nlevels(chefmozcuisine_df$Rcuisine))

# Calculate new RCuisine types
chefmozcuisine_df <- calculateRcuisine(chefmozcuisine_df)

# Drop unnecessary column
chefmozcuisine_df <- chefmozcuisine_df[,c("placeID", "Rcuisine")]
```

#### chefmozhours4

#### chefmozparking

#### geoplaces2

Select only relevant features.
Treat missing hours and create relevant features.

```{r}
rest_df <- geoplaces2_df[,c("placeID", "latitude", "longitude", "city", "alcohol", 
                            "smoking_area", "dress_code", "accessibility", "price", "Rambience",
                            "franchise", "area", "other_services")]

rest_st_df <- chefmozhours4_df[which(chefmozhours4_df$days == "Sat;"),]

rest_sd_df <- chefmozhours4_df[which(chefmozhours4_df$days == "Sun;"),]
rest_wk_df <- chefmozhours4_df[which(chefmozhours4_df$days == "Mon;Tue;Wed;Thu;Fri;"),]

rest_days_df <- merge(rest_st_df, rest_sd_df, by = "placeID")
rest_days_df <- merge(rest_days_df, rest_wk_df, by = "placeID")

setnames(rest_days_df, old=c("hours.x","hours.y","hours"), new=c("st", "sd","wk"))

rest_days_df <- rest_days_df[,c("placeID", "st", "sd","wk")]

rest_days_df <- rest_days_df[!duplicated(rest_days_df[c("placeID", "st", "sd","wk")]),]

rest_days_df <- data.frame(lapply(rest_days_df, as.character), stringsAsFactors = FALSE)
  
restaurant_df <- merge(rest_df, rest_days_df, by = "placeID", all.x = TRUE)

for(placeID in unique(restaurant_df$placeID)) {
  test <- restaurant_df[which(restaurant_df$placeID == placeID),]
  if(is.element("00:00-00:00;", test$st)){
    #Closed restaurant
    restaurant_df[which(restaurant_df$placeID == placeID),]$st <- 0
  } else {
    #Open restaurant (the Na will considered "open")
    restaurant_df[which(restaurant_df$placeID == placeID),]$st <- 1
  }
}

for(placeID in unique(restaurant_df$placeID)) {
  test <- restaurant_df[which(restaurant_df$placeID == placeID),]
  if(is.element("00:00-00:00;", test$sd)){
    #Closed restaurant
    restaurant_df[which(restaurant_df$placeID == placeID),]$sd <- 0
  } else {
    #Open restaurant (the Na will considered "open")
    restaurant_df[which(restaurant_df$placeID == placeID),]$sd <- 1
  }
}

for(placeID in unique(restaurant_df$placeID)) {
  test <- restaurant_df[which(restaurant_df$placeID == placeID),]
  if(is.element("00:00-00:00;", test$st)){
    #Closed restaurant
    restaurant_df[which(restaurant_df$placeID == placeID),]$wk <- 0
  } else {
    #Open restaurant (the Na will considered "open")
    restaurant_df[which(restaurant_df$placeID == placeID),]$wk <- 1
  }
}

geoplaces2_df <- restaurant_df
```

#### usercuisine

As discussed in chefmozcuisine section, a treatment to Rcuisine will be applied.

```{r}
sprintf("Rcuisine has %d levels.", nlevels(usercuisine_df$Rcuisine))

# Calculate new RCuisine types
usercuisine_df <- calculateRcuisine(usercuisine_df)

# Drop unnecessary column
usercuisine_df <- usercuisine_df[,c("userID", "Rcuisine")]
```

#### userpayment

#### userprofile

```{r}
sprintf("As seen in Data Understanding phase, userprofile dataset has %d missing values. The columns with missing values are 'smoker', 'ambience', 'transport', 'marital_status', 'hijos', 'activity' and 'budget'.", sum(userprofile_df == "?"))
```

'smoker' column:
```{r}
sprintf("1. 'smoker' column (nominal) has %d missing values, where %d are 'true' and %d are 'false. This means that the mode for this column is 'true'. In this case, and because it's preferrable to put a smoker person in a non-smoking restaurant than a non-smoker in a smoker restaurant, we will impute the missing values with 'true'.", sum(userprofile_df$smoker == "?"), sum(userprofile_df$smoker == 'true'), sum(userprofile_df$smoker == 'false'))

# Force NA's
userprofile_df[which(userprofile_df$smoker=="?"),]$smoker <- NA
length(which(is.na(userprofile_df$smoker)))
# Calculate mode
smoker_mode <- calculateMode(na.omit(userprofile_df$smoker))
smoker_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "smoker", Value=smoker_mode)
print(summary(userprofile_df$smoker))
```

'dress_preference' column:
This column has 5 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$dress_preference=="?"),]$dress_preference <- NA
length(which(is.na(userprofile_df$dress_preference)))
# Calculate mode
dress_preference_mode <- calculateMode(na.omit(userprofile_df$dress_preference))
dress_preference_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "dress_preference", Value=dress_preference_mode)
print(summary(userprofile_df$dress_preference))
```

'ambience' column:
This column has 6 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$ambience=="?"),]$ambience <- NA
length(which(is.na(userprofile_df$ambience)))
# Calculate mode
ambience_mode <- calculateMode(na.omit(userprofile_df$ambience))
ambience_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "ambience", Value=ambience_mode)
print(summary(userprofile_df$ambience))
```

'transport' column:
This column has 7 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$transport=="?"),]$transport <- NA
length(which(is.na(userprofile_df$transport)))
# Calculate mode
transport_mode <- calculateMode(na.omit(userprofile_df$transport))
transport_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "transport", Value=transport_mode)
print(summary(userprofile_df$transport))
```

'marital_status' column:
This column has 4 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$marital_status=="?"),]$marital_status <- NA
length(which(is.na(userprofile_df$marital_status)))
# Calculate mode
marital_status_mode <- calculateMode(na.omit(userprofile_df$marital_status))
marital_status_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "marital_status", Value=marital_status_mode)
print(summary(userprofile_df$marital_status))
```

'hijos' column:
This column has 11 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$hijos=="?"),]$hijos <- NA
length(which(is.na(userprofile_df$hijos)))
# Calculate mode
hijos_mode <- calculateMode(na.omit(userprofile_df$hijos))
hijos_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "hijos", Value=hijos_mode)
print(summary(userprofile_df$hijos))
```

'activity' column:
This column has 7 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$activity=="?"),]$activity <- NA
length(which(is.na(userprofile_df$activity)))
# Calculate mode
activity_mode <- calculateMode(na.omit(userprofile_df$activity))
activity_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "activity", Value=activity_mode)
print(summary(userprofile_df$activity))
```

'budget' column:
This column has 7 missing values. Because this is a column with nominal values, we will use mode as a susbtitute for NA's.
```{r}
# Force NA's
userprofile_df[which(userprofile_df$budget=="?"),]$budget <- NA
length(which(is.na(userprofile_df$budget)))
# Calculate mode
budget_mode <- calculateMode(na.omit(userprofile_df$budget))
budget_mode
# Substitute
userprofile_df <- imputation("value", userprofile_df, "budget", Value=budget_mode)
print(summary(userprofile_df$budget))
```

#### rating_final

To be able to use all the relevant features in the model, we need to create a dataframe with them.
```{r}
# Join dataframes
final_df <- merge(rating_final_df, chefmozaccepts_df, by = "placeID")
final_df <- merge(final_df, chefmozcuisine_df, by = "placeID")
final_df <- merge(final_df, chefmozhours4_df, by = "placeID")
final_df <- merge(final_df, chefmozparking_df, by = "placeID")
final_df <- merge(final_df, geoplaces2_df, by = "placeID")
final_df <- merge(final_df, usercuisine_df, by = "userID")
final_df <- merge(final_df, userpayment_df, by = "userID")
final_df <- merge(final_df, userprofile_df, by = "userID")

# Rename a column in R
colnames(final_df)[colnames(final_df)=="Rcuisine.x"] <- "Rcuisine"
colnames(final_df)[colnames(final_df)=="Rcuisine.y"] <- "UserRcuisine"

# Analyze final dataframe
# Columns
names(final_df)
# Number of attributes
ncol(final_df)
# Number of instances
nrow(final_df)
# Summary
summary(final_df)
# Head
head(final_df)
# Number of nulls
sum(final_df == "?")
# Number of nulls per column
colSums(final_df == "?")

# Drop unnecessary columns
final_df <- final_df[,c("rating","Rpayment", "days", "parking_lot", "Upayment", "smoker", "drink_level", "dress_preference", "ambience", "transport", "marital_status", "hijos", "interest", "personality", "religion", "activity", "color", "budget")]

# Dropped columns: userID, placeID, food_rating, service_rating, latitude, longitude, birth_year, weight, height, hours, UserRcuisine, Rcuisine
```

## Modeling

The main goal for this project is to predict the ratings that would be given by each customer for the restaurants that he/she didn't rate. In Data Understanding we saw that ratings are numerical values, so predicting their values can be treated as a regression problem. Using classification techniques is also reasonable since the possible ratings are three discrete integers: 0, 1 and 2.


### Holdout
As this is a supervised learning problem, the first step is to select the training and test datasets.
We will use the holdout technique.

```{r}

summary(final_df)
H = holdout(final_df$rating, ratio = 0.8)
```

### Neuronal Network

```{r}
?fit
Fi <- fit(rating~., final_df[H$tr,], model = "mlp")

P <- predict(Fi, final_df[H$ts,])

mmetric(final_df[H$ts,]$rating, P, metric = "MAE")
mmetric(final_df[H$ts,]$rating, P, metric = "MAPE")
```

## Evaluation

## Deployment

This step will not be executed.

# Bibliography

https://www.kaggle.com/liyenhsu/simple-content-based-recommenders

Get mode: https://www.tutorialspoint.com/r/r_mean_median_mode.htm





